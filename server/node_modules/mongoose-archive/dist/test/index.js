/**
 * Mongoose archive plugin test
 * @license MIT
 * @author 0@39.yt (Yurij Mikhalevich)
 * @module 'mongoose-archive-test'
 */

'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _mongoose = require('mongoose');

var _mongoose2 = _interopRequireDefault(_mongoose);

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

describe('mongooseArchive', function () {
  var _this = this;

  _mongoose2['default'].connect('mongodb://localhost/mongoose-archive-test');

  var TestDocumentSchema = new _mongoose.Schema({
    fieldA: {
      type: String,
      'default': 'Hello, AutoLotto!'
    },
    fieldB: {
      type: Number,
      'default': 1337
    }
  });

  TestDocumentSchema.plugin(_index2['default']);

  var TestDocument = _mongoose2['default'].model('test-document', TestDocumentSchema);

  var test1 = new TestDocument();
  var testDocs = [test1, new TestDocument(), new TestDocument()];

  before(function callee$1$0() {
    var i;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          i = 0;

        case 1:
          if (!(i < testDocs.length)) {
            context$2$0.next = 7;
            break;
          }

          context$2$0.next = 4;
          return _regeneratorRuntime.awrap(testDocs[i].save());

        case 4:
          ++i;
          context$2$0.next = 1;
          break;

        case 7:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });

  after(function callee$1$0() {
    var i;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          i = 0;

        case 1:
          if (!(i < testDocs.length)) {
            context$2$0.next = 7;
            break;
          }

          context$2$0.next = 4;
          return _regeneratorRuntime.awrap(testDocs[i].remove());

        case 4:
          ++i;
          context$2$0.next = 1;
          break;

        case 7:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });

  it('should be possible to archive a document', function callee$1$0() {
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(test1.archive());

        case 2:
          _assert2['default'].notStrictEqual(test1.archivedAt, undefined);

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });

  it('shouldn\'t appear in empty find query results after archiving', function callee$1$0() {
    var docs;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          _assert2['default'].notStrictEqual(test1.archivedAt, undefined, 'document \'test1\' should be archived');
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap(TestDocument.find());

        case 3:
          docs = context$2$0.sent;

          _assert2['default'].equal(docs.length, 2);

        case 5:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });

  it('should be possible to query archived document by specifying archivedAt filter', function callee$1$0() {
    var docs, doc;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          _assert2['default'].notStrictEqual(test1.archivedAt, undefined, 'document \'test1\' should be archived');
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap(TestDocument.find({ archivedAt: { $exists: true } }));

        case 3:
          docs = context$2$0.sent;

          _assert2['default'].equal(docs.length, 1);
          context$2$0.next = 7;
          return _regeneratorRuntime.awrap(TestDocument.findOne({ archivedAt: { $exists: true } }));

        case 7:
          doc = context$2$0.sent;

          _assert2['default'].deepEqual(docs[0].toObject(), doc.toObject());
          _assert2['default'].deepEqual(doc.toObject(), test1.toObject());

        case 10:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });

  it('should be possible to restore a document', function callee$1$0() {
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(test1.restore());

        case 2:
          _assert2['default'].strictEqual(test1.archivedAt, undefined);

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });

  it('should appear in empty find query results after restoring', function callee$1$0() {
    var docs;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          _assert2['default'].strictEqual(test1.archivedAt, undefined, 'document \'test1\' should be restored');
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap(TestDocument.find());

        case 3:
          docs = context$2$0.sent;

          _assert2['default'].equal(docs.length, 3);

        case 5:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
});
//# sourceMappingURL=index.js.map